#pragma once 

static const char *ui_vert = "#version 300 es\n"
"precision highp float;\n"
"precision highp sampler2D;\n"
"\n"
"#define UI_PRIM_RECTANGLE 1u\n"
"#define UI_PRIM_TRIANGLE 2u\n"
"#define UI_PRIM_TRIANGLE_ADVANCED 3u\n"
"#define GLYPH_MASK 0x80000000u\n"
"\n"
"#define UI_PRIM_GLYPH 32u\n"
"#define UI_PRIM_GLYPH_CODE 33u\n"
"\n"
"layout(location = 0) in highp uint vertex_id; // x, y, w, h\n"
"\n"
"uniform sampler2D primitive_buffer;\n"
"uniform vec3 window_size;\n"
"uniform float time;\n"
"\n"
"out vec4 clip_rect;\n"
"out vec4 color;\n"
"out vec2 sample_point;\n"
"out vec2 screen_point;\n"
"flat out highp uint type;\n"
"flat out highp uint clip;\n"
"\n"
"vec4 fetch_primitive_buffer(const uint pixel_index) {\n"
"    uint width = uint(textureSize(primitive_buffer, 0).x);\n"
"    uint y = pixel_index / width;\n"
"    uint x = pixel_index % width;\n"
"    return texelFetch(primitive_buffer, ivec2(x, y), 0);\n"
"}\n"
"\n"
"uint decode_primitive_type(uint id)\n"
"{\n"
"    return (id >> 26) & 0x3fu;\n"
"}\n"
"\n"
"highp uint decode_primitive_buffer_offset(uint id)\n"
"{\n"
"    return id & 0xffffffu;\n"
"}\n"
"\n"
"uint decode_corner_idx(uint id)\n"
"{\n"
"    return (id >> 24) & 0x3u;\n"
"}\n"
"\n"
"uint decode_header_offset(uint id)\n"
"{\n"
"    return (id >> 26) & 0x1fu;\n"
"}\n"
"\n"
"vec4 decode_color(float color)\n"
"{\n"
"    uint c = floatBitsToUint(color);\n"
"    return vec4(float((c >> 24) & 0xffu) / 255.0, float((c >> 16) & 0xffu) / 255.0, float((c >> 8) & 0xffu) / 255.0, float(c & 0xffu) / 255.0);\n"
"}\n"
"\n"
"vec4 rect_vertex(vec4 r, uint corner_idx)\n"
"{\n"
"    return vec4(r.x + ((corner_idx == 1u || corner_idx == 3u) ? r.z : 0.), r.y + ((corner_idx == 2u || corner_idx == 3u) ? r.w : 0.), 0., 1.);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    highp uint ptr = decode_primitive_buffer_offset(vertex_id);\n"
"    vec4 v = vec4(0., 0., 0., 1.0);\n"
"\n"
"    if ((vertex_id & GLYPH_MASK) != 0u) {\n"
"        // draw glyph\n"
"        uint corner_id = decode_corner_idx(vertex_id);\n"
"        uint header_offset = decode_header_offset(vertex_id);\n"
"        uint header_ptr = ptr - header_offset - 1u;\n"
"\n"
"        vec4 glyph_data = fetch_primitive_buffer(ptr);\n"
"        vec4 glyph_header = fetch_primitive_buffer(header_ptr);\n"
"        float glpyh_scale = glyph_data.w;\n"
"\n"
"        uint font_ptr = uint(glyph_header.z);\n"
"        vec4 font_data = fetch_primitive_buffer(font_ptr);\n"
"        uint glyph_ptr = font_ptr + 2u + uint(glyph_data.y) * 2u;\n"
"        vec2 font_texture_size = font_data.xy;\n"
"\n"
"        vec2 glyph_origin = glyph_header.xy;\n"
"        vec4 glyph_sample_rect = fetch_primitive_buffer(glyph_ptr);\n"
"        vec4 glyph_sample_data = fetch_primitive_buffer(glyph_ptr + 1u);\n"
"\n"
"        vec4 primitive_rect = vec4(glyph_origin + vec2(glyph_data.x, glyph_sample_data.y * glpyh_scale), glyph_sample_rect.zw * glpyh_scale);\n"
"\n"
"        v.xy = rect_vertex(primitive_rect, corner_id).xy;\n"
"        color = decode_color(glyph_data.z);\n"
"        uint raw_clip = uint(glyph_header.w);\n"
"        clip = raw_clip == 0u ? 0u : header_ptr - raw_clip;\n"
"\n"
"        sample_point = rect_vertex(glyph_sample_rect, corner_id).xy / font_texture_size;\n"
"        type = UI_PRIM_GLYPH + uint(font_data.z);\n"
"\n"
"    } else {\n"
"\n"
"        type = decode_primitive_type(vertex_id);\n"
"        if (type == UI_PRIM_RECTANGLE) {\n"
"\n"
"            uint corner_id = decode_corner_idx(vertex_id);\n"
"            vec4 primitive_data = fetch_primitive_buffer(ptr);\n"
"            vec4 rect_data = fetch_primitive_buffer(ptr + 1u);\n"
"\n"
"            v = rect_vertex(primitive_data, corner_id);\n"
"            color = decode_color(rect_data.x);\n"
"            uint raw_clip = uint(rect_data.y);\n"
"            clip = raw_clip == 0u ? 0u : ptr - raw_clip;\n"
"\n"
"        } else if (type == UI_PRIM_TRIANGLE) {\n"
"\n"
"            vec4 primitive_data = fetch_primitive_buffer(ptr);\n"
"            v.xy = primitive_data.xy;\n"
"            color = decode_color(primitive_data.z);\n"
"            uint raw_clip = uint(primitive_data.w);\n"
"            clip = raw_clip == 0u ? 0u : ptr - raw_clip;\n"
"\n"
"        } else {\n"
"\n"
"            vec4 primitive_data = fetch_primitive_buffer(ptr);\n"
"            v.xy = primitive_data.xy;\n"
"            color = decode_color(primitive_data.z);\n"
"            uint raw_clip = uint(primitive_data.w);\n"
"            clip = raw_clip == 0u ? 0u : ptr - raw_clip;\n"
"\n"
"            vec4 sample_data = fetch_primitive_buffer(ptr + 1u);\n"
"            sample_point = sample_data.xy;\n"
"\n"
"            type = uint(sample_data.z);\n"
"        }\n"
"    }\n"
"\n"
"    if (clip != 0u) {\n"
"        clip_rect = fetch_primitive_buffer(clip);\n"
"    }\n"
"\n"
"    screen_point = v.xy;\n"
"\n"
"    gl_Position = vec4(v.x * 2.0 - window_size.x, window_size.y - v.y * 2.0, 0.0, 1.0);\n"
"    gl_Position.xy /= window_size.xy;\n"
"}\n";

static const char* ui_frag = "#version 300 es\n"
"precision highp float;\n"
"precision highp sampler2D;\n"
"\n"
"#define UI_PRIM_RECTANGLE 1u\n"
"#define UI_PRIM_TRIANGLE 2u\n"
"#define UI_PRIM_TRIANGLE_ADVANCED 3u\n"
"\n"
"#define UI_PRIM_TRIANGLE_ADVANCED_ICON 4u\n"
"#define UI_PRIM_TRIANGLE_ADVANCED_SCREEN 5u\n"
"#define UI_PRIM_TRIANGLE_ADVANCED_ENTITY 6u\n"
"#define UI_PRIM_TRIANGLE_ADVANCED_ATLAS 7u\n"
"\n"
"#define UI_PRIM_GLYPH 32u\n"
"#define UI_PRIM_GLYPH_CODE 33u\n"
"\n"
"uniform sampler2D font_texture;\n"
"uniform sampler2D icon_texture;\n"
"uniform vec3 window_size;\n"
"\n"
"in vec4 color;\n"
"in vec4 clip_rect;\n"
"in vec2 sample_point;\n"
"in vec2 screen_point;\n"
"flat in highp uint type;\n"
"flat in uint clip;\n"
"\n"
"out vec4 frag_data;\n"
"\n"
"const float dash_stride = 12.f;\n"
"\n"
"float median(float r, float g, float b) {\n"
"  return max(min(r, g), min(max(r, g), b));\n"
"}\n"
"\n"
"bool contains(vec2 p, vec4 r) {\n"
"    return p.x >= r.x && p.y >= r.y && p.x <= (r.x + r.z) && p.y <= (r.y + r.w);\n"
"}\n"
"\n"
"vec3 hsl_to_rgb(in vec3 c) {\n"
"    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n"
"    return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));\n"
"}\n"
"\n"
"float radical_inverse(uint i) {\n"
"  i = (i << 16u) | (i >> 16u);\n"
"  i = ((i & 0x55555555u) << 1u) | ((i & 0xAAAAAAAAu) >> 1u);\n"
"  i = ((i & 0x33333333u) << 2u) | ((i & 0xCCCCCCCCu) >> 2u);\n"
"  i = ((i & 0x0F0F0F0Fu) << 4u) | ((i & 0xF0F0F0F0u) >> 4u);\n"
"  i = ((i & 0x00FF00FFu) << 8u) | ((i & 0xFF00FF00u) >> 8u);\n"
"  return float(i) * 2.32830643653086963e-10;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    if (clip != 0u) {\n"
"        if (!contains(screen_point, clip_rect)) discard;\n"
"    }\n"
"\n"
"    switch(type) {\n"
"        case UI_PRIM_GLYPH:\n"
"        {\n"
"            // fwidth version\n"
"            vec3 msdf = texture(font_texture, sample_point).xyz;\n"
"            float sd = median(msdf.r, msdf.g, msdf.b);\n"
"            float w = fwidth(sd);\n"
"            float opacity = smoothstep(0.5 - w, 0.5 + w, sd);\n"
"            frag_data = vec4(color.xyz, opacity);\n"
"            break;\n"
"        }\n"
"        case UI_PRIM_TRIANGLE_ADVANCED_ICON:\n"
"        {\n"
"            frag_data = texture(icon_texture, vec2(sample_point.x, 1.0 - sample_point.y));\n"
"            break;\n"
"        }\n"
"        default: {\n"
"            frag_data = color;\n"
"            break;\n"
"        }\n"
"    }\n"
"}\n";
